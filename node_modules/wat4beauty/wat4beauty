#!/usr/bin/env node

function formatWatSmart(watContent, alignIndentsWith = "\t", exportPadStart = 90) {

    function alignIndents(watContent) {
        let depth = 0;
        const TAB = alignIndentsWith || "\t";
        return watContent
            .split("\n")
            .map(line => {
                const trimmed = line.trim();
                if (!trimmed) return "";

                // --- 1. AdÄ±m: Hesaplama iÃ§in "Temiz" SatÄ±rÄ± OluÅŸtur ---
                // YorumlarÄ± (;;) ve tÄ±rnak iÃ§indeki stringleri ("...") geÃ§ici olarak siliyoruz.
                // Bu sayede yorumdaki veya stringdeki parantezler sayÄ±mÄ± bozmaz.
                let cleanLine = trimmed
                    .replace(/;;.*/g, "")         // YorumlarÄ± sil
                    .replace(/"[^"]*"/g, '""');   // String iÃ§lerini boÅŸalt

                // --- 2. AdÄ±m: Parantez Bakiyesini Hesapla ---
                const openCount = (cleanLine.match(/\(/g) || []).length;
                const closeCount = (cleanLine.match(/\)/g) || []).length;

                // SatÄ±rÄ±n BAÅINDAKÄ° kapanÄ±ÅŸ parantezlerini say (Ã–rn: "))" ile baÅŸlÄ±yorsa)
                // Bu, o satÄ±rÄ±n kendisini geri Ã§ekmek iÃ§in lazÄ±m.
                let leadingCloseCount = 0;
                for (let char of cleanLine) {
                    if (char === ')') leadingCloseCount++;
                    else if (char === '(') break; // AÃ§Ä±lÄ±ÅŸ gelirse dur
                    else if (char === ' ') continue; // BoÅŸluklarÄ± atla
                    else break; // BaÅŸka karakter gelirse dur
                }

                // --- 3. AdÄ±m: O anki satÄ±rÄ± bas ---
                // SatÄ±rÄ±n kendi seviyesi = Mevcut Derinlik - BaÅŸlangÄ±Ã§taki KapanÄ±ÅŸlar
                let printDepth = Math.max(0, depth - leadingCloseCount);
                const indentation = TAB.repeat(printDepth);

                // --- 4. AdÄ±m: Gelecek satÄ±r iÃ§in derinliÄŸi gÃ¼ncelle ---
                // Net deÄŸiÅŸim = AÃ§Ä±lan - Kapanan
                // NOT: Senin istediÄŸin "aynÄ± satÄ±rda aÃ§Ä±lÄ±p kapananlar" burada otomatik olarak
                // birbirini gÃ¶tÃ¼rÃ¼r (1 - 1 = 0) ve derinliÄŸi deÄŸiÅŸtirmez.
                depth += (openCount - closeCount);

                return `${indentation}${trimmed}`;
            })
            .join("\n");
    };

    function alignGlobals(watContent) {
        const lines = watContent.split("\n");
        const globalUpdates = []; // Hangi satÄ±rlarÄ±n global olduÄŸunu tutacaÄŸÄ±z
        let maxNameLength = 0;

        // --- 1. TUR: KeÅŸif ---
        // TÃ¼m satÄ±rlarÄ± gez, globalleri bul ve en uzun ismi Ã¶lÃ§.
        lines.forEach((line, index) => {
            // Regex AÃ§Ä±klamasÄ±:
            // ^(\s*\(global\s+) -> Grup 1: Girinti + "(global " kelimesi
            // (\S+)             -> Grup 2: Global ismi (boÅŸluk olmayan her ÅŸey)
            // \s+               -> Ä°simden sonraki (atÄ±lacak) boÅŸluklar
            // (.*)$             -> Grup 3: SatÄ±rÄ±n geri kalanÄ± (tip tanÄ±mlarÄ± vs.)
            const match = line.match(/^(\s*\(global\s+)(\S+)\s+(.*)$/);

            if (match) {
                const name = match[2];
                if (name.length > maxNameLength) {
                    maxNameLength = name.length;
                }

                // Bu satÄ±rÄ± ve parÃ§alarÄ±nÄ± daha sonra kullanmak Ã¼zere sakla
                globalUpdates.push({
                    index: index,
                    prefix: match[1], // "  (global " kÄ±smÄ±
                    name: name,       // "$self.Object" kÄ±smÄ±
                    rest: match[3]    // "(mut externref)..." kÄ±smÄ±
                });
            }
        });

        // Kural 2: En uzun isme 1 ekle (Minimum boÅŸluk garantisi)
        const alignLength = maxNameLength + 1;

        // --- 2. TUR: Uygulama ---
        // Sadece global satÄ±rlarÄ±nÄ± gÃ¼ncelle
        globalUpdates.forEach(update => {
            // Kural 3: Ä°sim uzunluÄŸunu bul ve aradaki boÅŸluÄŸu hesapla
            const currentNameLength = update.name.length;

            // Hedef uzunluktan ismin uzunluÄŸunu Ã§Ä±kar
            const spacesNeeded = alignLength - currentNameLength;

            // BoÅŸluk stringini oluÅŸtur
            const padding = " ".repeat(Math.max(1, spacesNeeded));

            // ParÃ§alarÄ± birleÅŸtir: Prefix + Ä°sim + Yeni BoÅŸluklar + Geri Kalan
            // Not: update.rest'i trim() yapÄ±yoruz ki, eski dÃ¼zensiz boÅŸluklar gitsin.
            const newLine = `${update.prefix}${update.name}${padding}${update.rest.trim()}`;

            // Orijinal satÄ±rÄ± gÃ¼ncelle
            lines[update.index] = newLine;
        });

        return lines.join("\n");
    };

    function alignImports(watContent) {
        const lines = watContent.split("\n");
        const importUpdates = [];
        let maxDefLength = 0;

        lines.forEach((line, index) => {
            // Regex AÃ§Ä±klamasÄ±:
            // ^(\s*\(import\s+)        -> Grup 1: Girinti + "(import "
            // ("[^"]*"\s+"[^"]*")      -> Grup 2: Ä°ki string bloÄŸu (ModÃ¼l ve Ä°sim) - BurasÄ± Ã¶lÃ§Ã¼lecek
            // (.*)$                    -> Grup 3: SatÄ±rÄ±n geri kalanÄ± (imza, tip vb.)

            // Not: Bu regex tam senin dediÄŸin gibi 1. tÄ±rnak ile 4. tÄ±rnak arasÄ±nÄ± (iÃ§indekilerle beraber) yakalar.
            const match = line.match(/^(\s*\(import\s+)("[^"]*"\s+"[^"]*")(.*)$/);

            if (match) {
                const definitionPart = match[2]; // Ã–rn: "env" "log"

                if (definitionPart.length > maxDefLength) {
                    maxDefLength = definitionPart.length;
                }

                importUpdates.push({
                    index: index,
                    prefix: match[1],      // "  (import "
                    definition: definitionPart,
                    rest: match[3]         // " (func $log...))"
                });
            }
        });

        // En uzun tanÄ±ma +1 ekleyerek hizalama sÄ±nÄ±rÄ±nÄ± belirle
        const alignTarget = maxDefLength + 1;

        // Hesaplanan boÅŸluklarla satÄ±rlarÄ± yeniden Ã¶r
        importUpdates.forEach(update => {
            const currentLen = update.definition.length;
            const paddingNeeded = alignTarget - currentLen;
            const padding = " ".repeat(Math.max(1, paddingNeeded));

            // ParÃ§alarÄ± birleÅŸtir
            // update.rest.trim() yaparak imza kÄ±smÄ±nÄ±n baÅŸÄ±ndaki dÃ¼zensiz boÅŸluÄŸu atÄ±yoruz.
            lines[update.index] = `${update.prefix}${update.definition}${padding}${update.rest.trim()}`;
        });

        return lines.join("\n");
    };

    function alignImportItemsPerfectly(watContent) {
        const lines = watContent.split("\n");
        const updates = [];
        let maxHeaderLength = 0; // "tip + isim" toplam uzunluÄŸu iÃ§in

        lines.forEach((line, index) => {
            // Regex AÃ§Ä±klamasÄ±:
            // ^(\s*\(import\s+.*\()    -> Grup 1: Prefix (parantez aÃ§Ä±lÄ±ÅŸÄ±na kadar)
            // (func|global|table|memory) -> Grup 2: TÄ°P (keyword)
            // \s+                      -> Aradaki boÅŸluk
            // (\$[^\s)]+)              -> Grup 3: Ä°SÄ°M ($variable)
            // (.*)$                    -> Grup 4: Geri kalan (Rest)
            const match = line.match(/^(\s*\(import\s+.*\()((?:func|global|table|memory))\s+(\$[^\s)]+)(.*)$/);

            if (match) {
                const type = match[2]; // Ã¶rn: "func" veya "global"
                const name = match[3]; // Ã¶rn: "$add"

                // Kritik Hesaplama: Tipin uzunluÄŸu + 1 boÅŸluk + Ä°smin uzunluÄŸu
                // Bu bize "func $add" bloÄŸunun toplam kapladÄ±ÄŸÄ± yeri verir.
                const currentHeaderLength = type.length + 1 + name.length;

                if (currentHeaderLength > maxHeaderLength) {
                    maxHeaderLength = currentHeaderLength;
                }

                updates.push({
                    index: index,
                    prefix: match[1], // "  (import "mod" "item" ("
                    type: type,       // "func"
                    name: name,       // "$add"
                    headerLen: currentHeaderLength,
                    rest: match[4]    // " (param i32)..."
                });
            }
        });

        // En uzun baÅŸlÄ±ÄŸa 1 karakter gÃ¼venli boÅŸluk ekle
        const alignTarget = maxHeaderLength + 1;

        updates.forEach(update => {
            // Ne kadar dolgu boÅŸluÄŸu lazÄ±m?
            // Hedef - Åu anki toplam uzunluk
            const paddingNeeded = alignTarget - update.headerLen;
            const padding = " ".repeat(Math.max(1, paddingNeeded));

            // Yeniden montaj:
            // Prefix + Tip + " " + Ä°sim + HESAPLANAN_DOLGU + Geri Kalan
            lines[update.index] = `${update.prefix}${update.type} ${update.name}${padding}${update.rest.trim()}`;
        });

        return lines.join("\n");
    };

    function formatWatNearPerfectRestored(watContent) {

        const namableMatches = Array.from(
            watContent.matchAll(
                /\((param|local|type)\s+\$(.[^\s]*)\s+(.[^\s]*)\)/g
            )
        );

        const unNamedMatches = Array
            .from(
                watContent.matchAll(
                    /\((param|local|type|result)((\s(i32|f32|i64|f64|externref|funcref|v128))+)\)/g
                )
            )
            .filter(m => !namableMatches.some(a => a.index === m.index))
            .map(m => Object.defineProperties(m, { 3: { value: m[2] }, 2: { value: "" } }))
            ;

        const matches = namableMatches
            .concat(unNamedMatches)
            .sort((a, b) => b.index - a.index)
            ;

        const replace = new Array();
        let maxLineLength = -Infinity;

        matches
            .filter(m => {
                const wrapperFuncBegin = watContent.lastIndexOf("\n", watContent.lastIndexOf("(func", m.index));
                const wrapperNextEOL = watContent.indexOf("\n", wrapperFuncBegin);
                const wrapperFuncLine = watContent.substring(wrapperFuncBegin, wrapperNextEOL);

                return wrapperFuncLine.split("(").length !== wrapperFuncLine.split(")").length;
            })
            .forEach(match => {
                let [line, tag, name, kind] = match;

                const length = String(line).length;
                const begin = match.index;
                const end = begin + length;

                if (name.length > 0) {
                    name = `$${name} `
                }

                const lineLeft = `(${tag} ${name}`;
                const lineRight = ` ${kind})`;

                maxLineLength = Math.max(maxLineLength, length);
                replace.push({ begin, end, lineLeft, lineRight });
            });

        replace
            .forEach(({ begin, end, lineLeft, lineRight }) => {
                const padding = maxLineLength - (lineLeft.length + lineRight.length) + 1;
                const newLine = lineLeft.concat(" ".repeat(padding)).concat(lineRight);

                watContent = ""
                    .concat(watContent.substring(0, begin))
                    .concat(newLine)
                    .concat(watContent.substring(end))
                    ;
            });

        return watContent;
    };

    function alignExportsRight(watContent) {

        return watContent.split("\n").map(line => {
            // 1. Export tanÄ±mÄ±nÄ± yakala: (export "...")
            // Bu regex, tÄ±rnak iÃ§indeki kaÃ§Ä±ÅŸ karakterlerini (\") de gÃ¼venle atlar.
            const exportRegex = /\(export\s+"(?:[^"\\]|\\.)*"\)/;
            const match = line.match(exportRegex);

            // EÄŸer satÄ±rda export yoksa olduÄŸu gibi bÄ±rak
            if (!match) return line;

            const exportPart = match[0];
            const targetColumn = exportPadStart || 90;

            // 2. Export'u satÄ±rdan geÃ§ici olarak sÃ¶kÃ¼p al
            // replace sadece ilk eÅŸleÅŸmeyi siler, bu tam istediÄŸimiz ÅŸey.
            let leftSide = line.replace(exportPart, "");

            // Sildikten sonra sonda kalan gereksiz boÅŸluklarÄ± temizle
            // Ã–NEMLÄ°: trim() deÄŸil trimEnd() kullanÄ±yoruz ki baÅŸtaki girinti (indent) bozulmasÄ±n.
            leftSide = leftSide.trimEnd();

            // 3. Mesafe HesabÄ± (Hedef: 70. Karakter)
            const currentLength = leftSide.length;

            // Hedefe ulaÅŸmak iÃ§in kaÃ§ boÅŸluk lazÄ±m?
            let paddingCount = targetColumn - currentLength - exportPart.length;

            // EÄŸer satÄ±r zaten 70'i geÃ§tiyse veya Ã§ok yakÄ±nsa (Ã§akÄ±ÅŸmamasÄ± iÃ§in) en az 1 boÅŸluk bÄ±rak
            if (paddingCount < 1) {
                paddingCount = 1;
            }

            // 4. BirleÅŸtir: Sol Taraf + BoÅŸluklar + Export
            return `${leftSide}${" ".repeat(paddingCount)}${exportPart}`;
        }).join("\n");
    };

    watContent = alignIndents(watContent);
    watContent = alignGlobals(watContent);
    watContent = alignImports(watContent);
    watContent = alignImportItemsPerfectly(watContent);
    watContent = formatWatNearPerfectRestored(watContent);
    watContent = alignExportsRight(watContent);

    return watContent;
}

import fs from "fs";
import path from "path";

// Ana kÃ¼tÃ¼phanemizden fonksiyonu Ã§aÄŸÄ±ralÄ±m.
// (Not: Dosya yapÄ±na gÃ¶re path'i ayarlarsÄ±n, genelde bir Ã¼st dizindeki index.js olur)
// --- Parsing Arguments ---
const args = process.argv.slice(2);

// Default Settings
let inputFile = null;
let outputFile = null;
let indentChar = "\t";   // Default: Tab
let exportPad = 70;      // Default: 70
let printOnly = false;
let showHelp = false;

// Arguments Loop
for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    switch (arg) {
        case '-h':
        case '--help':
            showHelp = true;
            break;

        case '-a':
        case '--align-indents-with':
            // Take the next argument if it exists and isn't a flag
            if (args[i + 1] && !args[i + 1].startsWith('-')) {
                indentChar = args[i + 1];
                i++; // Skip next arg since we consumed it
            } else {
                console.warn("âš ï¸ Warning: No value provided for -a, using default (Tab).");
            }
            break;

        case '-e':
        case '--export-pad-start':
            // Expecting a number
            if (args[i + 1] && !isNaN(parseInt(args[i + 1]))) {
                exportPad = parseInt(args[i + 1]);
                i++;
            } else {
                // Keep default 70 if invalid or missing
            }
            break;

        case '-o':
        case '--output':
            if (args[i + 1] && !args[i + 1].startsWith('-')) {
                outputFile = args[i + 1];
                i++;
            } else {
                console.error("âŒ Error: You must specify a file path after -o.");
                process.exit(1);
            }
            break;

        case '-p':
        case '--print-only':
            printOnly = true;
            break;

        default:
            // If it doesn't start with a flag, assume it's the input file
            if (!arg.startsWith('-')) {
                inputFile = arg;
            }
            break;
    }
}

// --- Help Screen ---
if (showHelp || args.length === 0) {
    console.log(`
\x1b[36mwat4beauty CLI\x1b[0m - WebAssembly Text Format Beautifier ğŸ’…

\x1b[33mUsage:\x1b[0m
  wat4beauty <file.wat> [options]

\x1b[33mOptions:\x1b[0m
  -a, --align-indents-with <str>  Indentation character (e.g. "  " or "\\t"). Default: Tab
  -e, --export-pad-start <num>    Column to align export definitions. Default: 70
  -o, --output <file>             Output file path. Prints to stdout if not specified.
  -p, --print-only                Prints to stdout instead of writing to a file.
  -h, --help                      Shows this help screen.

\x1b[33mExample:\x1b[0m
  wat4beauty test.wat -a "  " -e 80 -o result.wat
    `);
    process.exit(0);
}

// --- Execution Logic ---

if (!inputFile) {
    console.error("âŒ Error: Please specify a .wat file to format.");
    process.exit(1);
}

// Resolve absolute path
const absoluteInputPath = path.resolve(process.cwd(), inputFile);

if (!fs.existsSync(absoluteInputPath)) {
    console.error(`âŒ Error: File not found -> ${inputFile}`);
    process.exit(1);
}

try {
    // 1. Read File
    const content = fs.readFileSync(absoluteInputPath, 'utf8');

    // 2. Beautify (Our function)
    const formatted = formatWatSmart(content, indentChar, exportPad);

    // 3. Process Result
    if (outputFile && !printOnly) {
        // Write to File
        const absoluteOutputPath = path.resolve(process.cwd(), outputFile);
        fs.writeFileSync(absoluteOutputPath, formatted, 'utf8');
        console.log(`âœ… Success! File saved to: \x1b[32m${outputFile}\x1b[0m`);
    } else {
        // Print to Stdout
        console.log(formatted);
    }

} catch (error) {
    console.error("âŒ Unexpected error occurred:", error.message);
    process.exit(1);
}