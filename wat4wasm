#!/usr/bin/env node
import fs from "fs";
import cp, { spawnSync } from "child_process";

function wat4beauty(watContent, alignIndentsWith = "\t", exportPadStart = 90) {

    function alignIndents(watContent) {
        let depth = 0;
        const TAB = alignIndentsWith || "\t";
        return watContent
            .split("\n")
            .map(line => {
                const trimmed = line.trim();
                if (!trimmed) return "";

                // --- 1. Adım: Hesaplama için "Temiz" Satırı Oluştur ---
                // Yorumları (;;) ve tırnak içindeki stringleri ("...") geçici olarak siliyoruz.
                // Bu sayede yorumdaki veya stringdeki parantezler sayımı bozmaz.
                let cleanLine = trimmed
                    .replace(/;;.*/g, "")         // Yorumları sil
                    .replace(/"[^"]*"/g, '""');   // String içlerini boşalt

                // --- 2. Adım: Parantez Bakiyesini Hesapla ---
                const openCount = (cleanLine.match(/\(/g) || []).length;
                const closeCount = (cleanLine.match(/\)/g) || []).length;

                // Satırın BAŞINDAKİ kapanış parantezlerini say (Örn: "))" ile başlıyorsa)
                // Bu, o satırın kendisini geri çekmek için lazım.
                let leadingCloseCount = 0;
                for (let char of cleanLine) {
                    if (char === ')') leadingCloseCount++;
                    else if (char === '(') break; // Açılış gelirse dur
                    else if (char === ' ') continue; // Boşlukları atla
                    else break; // Başka karakter gelirse dur
                }

                // --- 3. Adım: O anki satırı bas ---
                // Satırın kendi seviyesi = Mevcut Derinlik - Başlangıçtaki Kapanışlar
                let printDepth = Math.max(0, depth - leadingCloseCount);
                const indentation = TAB.repeat(printDepth);

                // --- 4. Adım: Gelecek satır için derinliği güncelle ---
                // Net değişim = Açılan - Kapanan
                // NOT: Senin istediğin "aynı satırda açılıp kapananlar" burada otomatik olarak
                // birbirini götürür (1 - 1 = 0) ve derinliği değiştirmez.
                depth += (openCount - closeCount);

                return `${indentation}${trimmed}`;
            })
            .join("\n");
    };

    function alignGlobals(watContent) {
        const lines = watContent.split("\n");
        const globalUpdates = []; // Hangi satırların global olduğunu tutacağız
        let maxNameLength = 0;

        // --- 1. TUR: Keşif ---
        // Tüm satırları gez, globalleri bul ve en uzun ismi ölç.
        lines.forEach((line, index) => {
            // Regex Açıklaması:
            // ^(\s*\(global\s+) -> Grup 1: Girinti + "(global " kelimesi
            // (\S+)             -> Grup 2: Global ismi (boşluk olmayan her şey)
            // \s+               -> İsimden sonraki (atılacak) boşluklar
            // (.*)$             -> Grup 3: Satırın geri kalanı (tip tanımları vs.)
            const match = line.match(/^(\s*\(global\s+)(\S+)\s+(.*)$/);

            if (match) {
                const name = match[2];
                if (name.length > maxNameLength) {
                    maxNameLength = name.length;
                }

                // Bu satırı ve parçalarını daha sonra kullanmak üzere sakla
                globalUpdates.push({
                    index: index,
                    prefix: match[1], // "  (global " kısmı
                    name: name,       // "$self.Object" kısmı
                    rest: match[3]    // "(mut externref)..." kısmı
                });
            }
        });

        // Kural 2: En uzun isme 1 ekle (Minimum boşluk garantisi)
        const alignLength = maxNameLength + 1;

        // --- 2. TUR: Uygulama ---
        // Sadece global satırlarını güncelle
        globalUpdates.forEach(update => {
            // Kural 3: İsim uzunluğunu bul ve aradaki boşluğu hesapla
            const currentNameLength = update.name.length;

            // Hedef uzunluktan ismin uzunluğunu çıkar
            const spacesNeeded = alignLength - currentNameLength;

            // Boşluk stringini oluştur
            const padding = " ".repeat(Math.max(1, spacesNeeded));

            // Parçaları birleştir: Prefix + İsim + Yeni Boşluklar + Geri Kalan
            // Not: update.rest'i trim() yapıyoruz ki, eski düzensiz boşluklar gitsin.
            const newLine = `${update.prefix}${update.name}${padding}${update.rest.trim()}`;

            // Orijinal satırı güncelle
            lines[update.index] = newLine;
        });

        return lines.join("\n");
    };

    function alignImports(watContent) {
        const lines = watContent.split("\n");
        const importUpdates = [];
        let maxDefLength = 0;

        lines.forEach((line, index) => {
            // Regex Açıklaması:
            // ^(\s*\(import\s+)        -> Grup 1: Girinti + "(import "
            // ("[^"]*"\s+"[^"]*")      -> Grup 2: İki string bloğu (Modül ve İsim) - Burası ölçülecek
            // (.*)$                    -> Grup 3: Satırın geri kalanı (imza, tip vb.)

            // Not: Bu regex tam senin dediğin gibi 1. tırnak ile 4. tırnak arasını (içindekilerle beraber) yakalar.
            const match = line.match(/^(\s*\(import\s+)("[^"]*"\s+"[^"]*")(.*)$/);

            if (match) {
                const definitionPart = match[2]; // Örn: "env" "log"

                if (definitionPart.length > maxDefLength) {
                    maxDefLength = definitionPart.length;
                }

                importUpdates.push({
                    index: index,
                    prefix: match[1],      // "  (import "
                    definition: definitionPart,
                    rest: match[3]         // " (func $log...))"
                });
            }
        });

        // En uzun tanıma +1 ekleyerek hizalama sınırını belirle
        const alignTarget = maxDefLength + 1;

        // Hesaplanan boşluklarla satırları yeniden ör
        importUpdates.forEach(update => {
            const currentLen = update.definition.length;
            const paddingNeeded = alignTarget - currentLen;
            const padding = " ".repeat(Math.max(1, paddingNeeded));

            // Parçaları birleştir
            // update.rest.trim() yaparak imza kısmının başındaki düzensiz boşluğu atıyoruz.
            lines[update.index] = `${update.prefix}${update.definition}${padding}${update.rest.trim()}`;
        });

        return lines.join("\n");
    };

    function alignImportItemsPerfectly(watContent) {
        const lines = watContent.split("\n");
        const updates = [];
        let maxHeaderLength = 0; // "tip + isim" toplam uzunluğu için

        lines.forEach((line, index) => {
            // Regex Açıklaması:
            // ^(\s*\(import\s+.*\()    -> Grup 1: Prefix (parantez açılışına kadar)
            // (func|global|table|memory) -> Grup 2: TİP (keyword)
            // \s+                      -> Aradaki boşluk
            // (\$[^\s)]+)              -> Grup 3: İSİM ($variable)
            // (.*)$                    -> Grup 4: Geri kalan (Rest)
            const match = line.match(/^(\s*\(import\s+.*\()((?:func|global|table|memory))\s+(\$[^\s)]+)(.*)$/);

            if (match) {
                const type = match[2]; // örn: "func" veya "global"
                const name = match[3]; // örn: "$add"

                // Kritik Hesaplama: Tipin uzunluğu + 1 boşluk + İsmin uzunluğu
                // Bu bize "func $add" bloğunun toplam kapladığı yeri verir.
                const currentHeaderLength = type.length + 1 + name.length;

                if (currentHeaderLength > maxHeaderLength) {
                    maxHeaderLength = currentHeaderLength;
                }

                updates.push({
                    index: index,
                    prefix: match[1], // "  (import "mod" "item" ("
                    type: type,       // "func"
                    name: name,       // "$add"
                    headerLen: currentHeaderLength,
                    rest: match[4]    // " (param i32)..."
                });
            }
        });

        // En uzun başlığa 1 karakter güvenli boşluk ekle
        const alignTarget = maxHeaderLength + 1;

        updates.forEach(update => {
            // Ne kadar dolgu boşluğu lazım?
            // Hedef - Şu anki toplam uzunluk
            const paddingNeeded = alignTarget - update.headerLen;
            const padding = " ".repeat(Math.max(1, paddingNeeded));

            // Yeniden montaj:
            // Prefix + Tip + " " + İsim + HESAPLANAN_DOLGU + Geri Kalan
            lines[update.index] = `${update.prefix}${update.type} ${update.name}${padding}${update.rest.trim()}`;
        });

        return lines.join("\n");
    };

    function formatWatNearPerfectRestored(watContent) {

        const namableMatches = Array.from(
            watContent.matchAll(
                /\((param|local|type)\s+\$(.[^\s]*)\s+(.[^\s]*)\)/g
            )
        );

        const unNamedMatches = Array
            .from(
                watContent.matchAll(
                    /\((param|local|type|result)((\s(i32|f32|i64|f64|externref|funcref|v128))+)\)/g
                )
            )
            .filter(m => !namableMatches.some(a => a.index === m.index))
            .map(m => Object.defineProperties(m, { 3: { value: m[2] }, 2: { value: "" } }))
            ;

        const matches = namableMatches
            .concat(unNamedMatches)
            .sort((a, b) => b.index - a.index)
            ;

        const replace = new Array();
        let maxLineLength = -Infinity;

        matches
            .filter(m => {
                const wrapperFuncBegin = watContent.lastIndexOf("\n", watContent.lastIndexOf("(func", m.index));
                const wrapperNextEOL = watContent.indexOf("\n", wrapperFuncBegin);
                const wrapperFuncLine = watContent.substring(wrapperFuncBegin, wrapperNextEOL);

                return wrapperFuncLine.split("(").length !== wrapperFuncLine.split(")").length;
            })
            .forEach(match => {
                let [line, tag, name, kind] = match;

                const length = String(line).length;
                const begin = match.index;
                const end = begin + length;

                if (name.length > 0) {
                    name = `$${name} `
                }

                const lineLeft = `(${tag} ${name}`;
                const lineRight = ` ${kind})`;

                maxLineLength = Math.max(maxLineLength, length);
                replace.push({ begin, end, lineLeft, lineRight });
            });

        replace
            .forEach(({ begin, end, lineLeft, lineRight }) => {
                const padding = maxLineLength - (lineLeft.length + lineRight.length) + 1;
                const newLine = lineLeft.concat(" ".repeat(padding)).concat(lineRight);

                watContent = ""
                    .concat(watContent.substring(0, begin))
                    .concat(newLine)
                    .concat(watContent.substring(end))
                    ;
            });

        return watContent;
    };

    function alignExportsRight(watContent) {

        return watContent.split("\n").map(line => {
            // 1. Export tanımını yakala: (export "...")
            // Bu regex, tırnak içindeki kaçış karakterlerini (\") de güvenle atlar.
            const exportRegex = /\(export\s+"(?:[^"\\]|\\.)*"\)/;
            const match = line.match(exportRegex);

            // Eğer satırda export yoksa olduğu gibi bırak
            if (!match) return line;

            const exportPart = match[0];
            const targetColumn = exportPadStart || 90;

            // 2. Export'u satırdan geçici olarak söküp al
            // replace sadece ilk eşleşmeyi siler, bu tam istediğimiz şey.
            let leftSide = line.replace(exportPart, "");

            // Sildikten sonra sonda kalan gereksiz boşlukları temizle
            // ÖNEMLİ: trim() değil trimEnd() kullanıyoruz ki baştaki girinti (indent) bozulmasın.
            leftSide = leftSide.trimEnd();

            // 3. Mesafe Hesabı (Hedef: 70. Karakter)
            const currentLength = leftSide.length;

            // Hedefe ulaşmak için kaç boşluk lazım?
            let paddingCount = targetColumn - currentLength - exportPart.length;

            // Eğer satır zaten 70'i geçtiyse veya çok yakınsa (çakışmaması için) en az 1 boşluk bırak
            if (paddingCount < 1) {
                paddingCount = 1;
            }

            // 4. Birleştir: Sol Taraf + Boşluklar + Export
            return `${leftSide}${" ".repeat(paddingCount)}${exportPart}`;
        }).join("\n");
    };

    watContent = alignIndents(watContent);
    watContent = alignGlobals(watContent);
    watContent = alignImports(watContent);
    watContent = alignImportItemsPerfectly(watContent);
    watContent = formatWatNearPerfectRestored(watContent);
    watContent = alignExportsRight(watContent);

    return watContent;
}const helpers = {
    hasProtocol(str) {
        return str?.includes("://");
    },
    parseProtoPath(path) {
        const [protocol, fullpath, filename, basename, extension] = path.match(/([a-z0-9]+\:\/\/)((?:(?:.*)\/)*((.[^\/]*)\.(.[^\.]*)))/).slice(1);
        const directory = fullpath.substring(0, fullpath.length - filename.length)
        return { protocol, fullpath, directory, filename, basename, extension };
    },
    readFileAsText(fullpath) {
        return fs.readFileSync(fullpath, "utf8");
    },
    readFileAsHex(fullpath) {
        const data = fs.readFileSync(fullpath, "hex").replaceAll(/(..)/g, `\\$1`);
        const size = data.length / 3;
        return { data, size };
    },
    unlinkFile(path) {
        return fs.unlinkSync(path);
    },
    copyFile(path, topath) {
        return fs.cpSync(path, topath);
    },
    spawnSync(command, argv) {
        return cp.spawnSync(command, argv, { stdio: "inherit" });
    },
    blockAt(raw, begin) {
        raw = raw.toString();
        if ((begin === -1) || !(raw = raw.substring(begin))) {
            return "";
        }
        let maskUsed = raw.includes("\\)");
        if (maskUsed) {
            maskUsed = `__RAND${Math.random()}__`;
            raw = raw.replaceAll("\\)", maskUsed);
        }
        let end = begin = 0, block = raw;
        end = raw.indexOf(")", end);
        block = raw.substring(begin, ++end);
        while (block && (
            block.split("(").length !==
            block.split(")").length)
        ) {
            end = raw.indexOf(")", end);
            block = raw.substring(begin, ++end);
        }
        if (maskUsed && block) {
            block = block.replaceAll(maskUsed, "\\)");
        }
        return block;
    },
    rawContent(block) {
        let raw = block.toString().trim();
        let begin;
        if (raw.startsWith("(")) {
            raw = raw.substring(1);
            while (raw && raw.at(0).match(/[a-z0-9\.\_\(\)]/)) {
                raw = raw.substring(1);
            }
            raw = raw.trim();
            if (raw.startsWith("$")) {
                while (raw && raw.at(0).match(/[a-z0-9A-Z\:\.\<\>\/\_\+\-\`\[\]\$\=\#\!]/)) {
                    raw = raw.substring(1)
                }
            }
            raw = raw.trim();
        }
        raw = raw.trim();
        if (raw.endsWith(")")) {
            raw = raw.substring(0, raw.length - 1)
            while (raw && !raw.at(-1).trim()) {
                raw = raw.substring(0, raw.length - 1)
            }
        }
        raw = raw.trim();
        return raw;
    },
    blockContent(block) {
        let raw = this.rawContent(block);
        while (raw.startsWith("(type")) { raw = raw.substring(raw.indexOf(")") + 1).trim(); }
        while (raw.startsWith("(param")) { raw = raw.substring(raw.indexOf(")") + 1).trim(); }
        while (raw.startsWith("(result")) { raw = raw.substring(raw.indexOf(")") + 1).trim(); }
        while (raw.startsWith("(local")) { raw = raw.substring(raw.indexOf(")") + 1).trim(); }
        raw = raw.trim();
        return raw;
    },
    containsMemoryOperation(raw) {
        return raw.toString().split(/(memory|i32|f32|i64|f64|v128)(\.)(init|load|store|atomic|fill|drop)/).length > 1;
    },
    prepend(raw, block) {
        raw = raw.toString();
        block = block.toString().trim().concat("\n\n");
        if (raw.startsWith("(module")) {
            return String(`(module\n${block}\n`).concat(
                raw.substring("(module".length).trimStart()
            )
        }
        if (raw.replaceAll(/\s+/g, '').match(/\(([a-z0-9\.\_]+)\)/)) {
            return raw.substring(0, raw.length - 1).concat(block).concat(`)`);
        }
        let begin;
        begin = raw.indexOf("(", 1);
        let headmatch = true;
        while (headmatch) {
            if (headmatch = raw.substring(begin).startsWith("(param")) { begin = raw.indexOf("(", ++begin); continue; }
            if (headmatch = raw.substring(begin).startsWith("(result")) { begin = raw.indexOf("(", ++begin); continue; }
            if (headmatch = raw.substring(begin).startsWith("(local")) { begin = raw.indexOf("(", ++begin); continue; }
            if (headmatch = raw.substring(begin).startsWith("(type")) { begin = raw.indexOf("(", ++begin); continue; }
        }
        if (begin !== -1) {
            return raw.substring(0, begin).concat(block).concat(raw.substring(begin))
        }
        const blockparts = raw.split(/\s+/).filter(Boolean);
        if (blockparts.length === 1) {
            return this.append(raw, block);
        }
        const maybe$name = blockparts.at(1);
        if (maybe$name.startsWith("$")) {
            if (maybe$name.endsWith(")")) {
                return this.append(raw, block);
            }
        }
        const [firstLine, ...restLines] = raw.split(/\n/g);
        return [firstLine, block, ...restLines].join("\n");
    },
    append(raw, block) {
        raw = raw.toString();
        return raw.substring(0, raw.lastIndexOf(")")).concat(`\n${block || ''}\n)`);
    },
    findQuotedTexts(rawBlock, maxcount = -1) {
        let maskUsed = rawBlock.includes('\\"');
        if (maskUsed) {
            maskUsed = `__RAND${Math.random()}__`;
            rawBlock = rawBlock.replaceAll('\\"', maskUsed);
        }
        let texts = [];
        let begin = rawBlock.indexOf(`"`);
        let end = rawBlock.indexOf(`"`, begin + 1);
        while (maxcount-- && begin !== -1) {
            texts.push(rawBlock.substring(begin + 1, end));
            begin = rawBlock.indexOf('"', end + 1);
            end = rawBlock.indexOf(`"`, begin + 1);
        }
        if (maskUsed) {
            texts = texts.map(t => t.replaceAll(maskUsed, "\\)"));
        }
        return texts;
    },
    findQuotedText(rawBlock) {
        return this.findQuotedTexts(rawBlock, 1).at(0);
    },
    encodeText: TextEncoder.prototype.encode.bind(new TextEncoder),
    encodeString: str => Array.from(str || '').map(c => c.charCodeAt()),
    fix$Name(keyword, self = false) {
        if (keyword.startsWith("$") === false) {
            return `$${keyword}`;
        }
        if (self && keyword.startsWith("$self") === false) {
            return `$self.${keyword.substring(1)}`;
        }
        return keyword;
    },
    fixBlockKeyword(keyword, filter = {}) {
        if (keyword.split(/\s/).length > 1) {
            throw new Error(`Given keyword is wrong: ${keyword}`)
        }
        if (filter.$name) {
            keyword = `${keyword} ${filter.$name}`;
        }
        if (filter.name) {
            keyword = `${keyword} $${filter.name}`;
        }
        if (keyword.startsWith("(") === false) {
            return `(${keyword}`;
        }
        return keyword;
    },
    getBlockKeyword(block) {
        let keyword = block;
        if (keyword.startsWith("(") === true) {
            keyword = keyword.substring(1);
        }
        let i = 0;
        while (keyword.at(i++).match(/[a-z0-9\_\.]/));;
        return keyword.substring(0, i);
    },
    getBlockRootTag(block) {
        return this.getBlockKeyword(block).split(".").at(0);
    },
    getBlockRootTagType(block) {
        return this.getBlockRootTag(block).match(/(i32|f32|i64|f64)/)?.at(0) || "ext";
    },
    getTableOperator(block) {
        let [match, $name = "", initial = "", maximum = "", kindof = "externref"] = block.toString().match(/\(table(?:\s*(.[^\s]*)?)\s+(\d+)(?:\s*(\d+)?)\s+(externref|funcref)\)/) ?? [];
        initial = parseInt(initial);
        maximum = parseInt(maximum);
        return {
            $name, initial, maximum, kindof,
            grow: function (count = 1) {
                return {
                    newTableBlock: `(table ${[$name, initial + count, maximum, kindof].filter(Boolean).join(" ").trim()})`,
                    getTableBlock: `(table.get ${[$name, `(i32.const ${initial})`].join(" ").trim()})`
                };
            }
        };
    },
    clearExceptKnown(raw) {
        return `${raw || ''}`.trim().split(/\n/)
            .map(l => l.replaceAll(/\s+/g, " "))
            .map(l => l.replace(/;;.*/g, ""))
            .map(l => l.replaceAll(/\(;(.*);\)/g, ""))
            .filter(l => l.replaceAll(/\s+/g, "").trim())
            .join(" ").replaceAll(/\s+(\)|\()/g, `$1`)
            ;
    },
    generateId(raw) {
        let sum = 0;
        this.clearExceptKnown(raw)
            .split("").map((c, i) => sum += c.charCodeAt() * i);
        return sum;
    },
    abstract(str, max = 15) {
        str = `${str || ''}`.replaceAll(/\s+/g, ' ').replaceAll(/\s+\)/g, ")");
        if (str.length < max) return str;
        return `${str.substring(0, max / 3)} ... ${str.substring(str.length - max / 3)}`
    },
    createTableGetter(index, kindof = "extern") {
        return `(ref.null (;${index};) ${kindof})`;
    },
    referenceId() {
        return "0x" + crypto.randomUUID().replace(/\-/g, "");
    },
    hasBlock(raw, keyword, filter) {
        if (!keyword) { return raw.indexOf("(", 1) !== -1; };
        keyword = this.fixBlockKeyword(keyword, filter);
        return raw.includes(keyword);
    },
    hasAnyBlock(raw) {
        return this.hasBlock(raw);
    },
    MaskSet: class MaskSet extends Map {
        constructor(raw) {
            raw = (raw || '').toString().trim();
            Reflect.defineProperty(super(), "input", { value: raw, writable: true })
        }
        remove(block) {
            if (!block || !block?.uuid) { return this.input; };
            if (this.has(block.uuid) !== false) {
                this.delete(block.uuid);
            }
            return this.mask(block, "");
        }
        mask(block, maskWith = block.uuid) {
            if (!block.uuid) {
                throw new Error(`Raw block needs uuid: ${block}`);
            };
            if (this.has(block.uuid) === false) {
                this.set(block.uuid, block);
            }
            const rawRange = this.input.substring(
                block.begin, block.end
            );
            if (block.toString() !== rawRange) {
                console.error({ block, rawRange })
                throw new Error(`Raw block pointer range is not matched!`);
            };
            this.input = this.input
                .substring(0, block.begin)
                .concat(block.maskWith = maskWith)
                .concat(this.input.substring(block.end))
                ;
        }
        unmask(block) {
            this.input = this.input.replaceAll(block.uuid, block.toString());
            return this;
        }
        lastBlockOf(keyword, filter) {
            return helpers.lastBlockOf(this.input, keyword, filter);
        }
        hasBlock(keyword, filter) {
            return helpers.hasBlock(this.input, keyword, filter);
        }
        update(oldBlock, newBlock) {
            this.set(oldBlock.uuid, newBlock);
        }
        get hasAnyBlock() {
            return this.input.trim().indexOf("(", 1) !== -1;
        }
        parseFirstBlock() {
            return helpers.parseFirstBlock(this.input);
        }
        refresh() {
            this.input = this.restoreInto(this.input);
            return this;
        }
        restore() {
            return this.refresh().restoreInto();
        }
        toString() {
            return this.input;
        }
        [Symbol.toPrimitive]() {
            return this.toString();
        }
        get rawContent() {
            return helpers.rawContent(this.restore())
        }
        get blockContent() {
            return helpers.blockContent(this.restore())
        }
        restoreInto(raw = this.input) {
            const masks = Array.from(this.keys());
            const uuid = masks.find(uuid => raw.includes(uuid));
            if (uuid) {
                const block = this.get(uuid);
                raw = raw.replaceAll(uuid, block.toString());
                return this.restoreInto(raw);
            }
            return raw;
        }
        generateId() {
            return helpers.generateId(this.restore())
        }
    },
    nameSignatureofGlobal($name) {
        return String($name || '')
            .match(/\$(.[^<]*)(?:\<(.[^>]*)\>)?/)?.slice(1) || [];
    },
    assignBlockProperties(raw, block, begin) {
        if (begin === -1) return null;
        let $name = block.split(/[^a-z0-9A-Z\:\.\<\>\/\_\+\-\`\[\]\$\=\#\!\*]/g).filter(Boolean).at(1) || "";
        let isGetter = false;
        let isSetter = false;
        let descriptorKey = "value";
        if ($name.startsWith("$") === false) {
            $name = "";
        }
        if ($name.includes("[")) {
            descriptorKey = $name.substring(
                $name.indexOf("[") + 1,
                $name.indexOf("]")
            );
            $name = $name.substring(0, $name.indexOf("[")).concat("/").concat(descriptorKey);
        }
        isGetter = descriptorKey === "get";
        isSetter = descriptorKey === "set";
        $name = $name
            .replaceAll(":", ".prototype.")
            .replaceAll(".TypedArray", ".Uint8Array.__proto__")
            ;
        return block && Object.defineProperties({
            block: `${block}`,
            begin,
            uuid: crypto.randomUUID(),
            end: begin + block.length,
            $name: $name || "",
            toString: function () { return this.block; },
            wrappedRaws: function () {
                return {
                    before: this.input.substring(0, this.begin),
                    after: this.input.substring(this.end)
                }
            },
            maskedRaw: function () { return this.replacedRaw(this.uuid); },
            removedRaw: function () { return this.replacedRaw(""); },
            replacedRaw: function (str) {
                const { before, after } = this.wrappedRaws();
                return before.concat(str.toString()).concat(after);
            },
        }, {
            isGetter: { value: isGetter },
            isSetter: { value: isSetter },
            descriptorKey: { value: descriptorKey },
            input: { value: raw },
            hasBlock: { value: function (keyword, filter) { return helpers.hasBlock(this.toString(), keyword, filter); } },
            blockName: {
                get: function () {
                    let rawContent = this.toString().trim();
                    let begin;
                    let blockName = ``;
                    if (rawContent.startsWith("(")) {
                        rawContent = rawContent.substring(1);
                        while (rawContent && rawContent.at(0).match(/[a-z0-9\.\_]/)) {
                            blockName = blockName + rawContent.at(0)
                            rawContent = rawContent.substring(1);
                        }
                    }
                    return blockName;
                }
            },
            generateId: { value: function () { return helpers.generateId(this.toString()) } },
            name: { get: function () { return `${this.$name}`.substring(1); } },
            rawContent: { get: function () { return helpers.rawContent(this.toString()) } },
            blockContent: { get: function () { return helpers.blockContent(this.toString()) } },
            hasAnyBlock: { get: function () { return helpers.hasAnyBlock(this.toString()) } },
            indexOf: { value: function () { return this.block.indexOf(...arguments) } },
            includes: { value: function () { return this.block.includes(...arguments) } },
            lastIndexOf: { value: function () { return this.block.lastIndexOf(...arguments) } },
            split: { value: function () { return this.block.split(...arguments) } },
            at: { value: function () { return this.block.at(...arguments) } },
            length: { get: function () { return this.block.length } },
            charCodeAt: { value: function () { return this.block.charCodeAt(...arguments) } },
            concat: { value: function () { return this.block.concat(...arguments) } },
            startsWith: { value: function () { return this.block.startsWith(...arguments) } },
            endsWith: { value: function () { return this.block.endsWith(...arguments) } },
            substring: { value: function () { return this.block.substring(...arguments) } },
            replace: { value: function () { return this.block.replace(...arguments) } },
            replaceAll: { value: function () { return this.block.replaceAll(...arguments) } },
            lastBlockOf: { value: function () { return helpers.lastBlockOf(this.block, ...arguments) } },
            [Symbol.toPrimitive]: { value: function () { return this.block; } },
        })
    },
    lastBlockOf(raw, keyword, filter) {
        if (!raw) throw new Error(`no raw for block: ${keyword}`);
        keyword = this.fixBlockKeyword(keyword, filter);
        raw = raw.toString();
        let begin = raw.lastIndexOf(keyword);
        const block = this.parseBlockAt(raw, begin);
        return block;
    },
    firstBlockOf(raw, keyword, filter) {
        if (!raw) throw new Error(`no raw for block: ${keyword}`);
        keyword = this.fixBlockKeyword(keyword, filter);
        raw = raw.toString();
        let begin = raw.indexOf(keyword);
        const block = this.parseBlockAt(raw, begin);
        return block;
    },
    parseBlockAt(raw, begin) {
        return this.assignBlockProperties(raw, this.blockAt(raw, begin), begin);
    },
    parseBlock(raw) {
        return this.parseFirstBlock(raw);
    },
    parseFirstBlock(raw) {
        raw = raw.toString();
        return this.parseBlockAt(raw, raw.indexOf("(", 1));
    }
};

const ASYNC_BLOCK_NAME = "async";
function ASYNC (wat, WAT4WASM) {
    const maskSet = new helpers.MaskSet(wat);
    const inlineFunctions = new Array();
    while (maskSet.hasBlock(ASYNC_BLOCK_NAME)) {
        const block = maskSet.lastBlockOf(ASYNC_BLOCK_NAME);
        const result = block.blockName.split(".").at(1) || "";
        let chain, step, $exit, $name, $prop, $func,
            steps = new helpers.MaskSet(block);
        steps.mask(chain = steps.parseFirstBlock());
        maskSet.mask(block);
        while (steps.hasAnyBlock) {
            steps.mask(step = steps.parseFirstBlock());
            $prop = step.blockName;
            $func = step.rawContent;
            $exit = steps.hasAnyBlock && "ext" || result;
            if ($func.startsWith("ref.func")) {
                $name = `$${$func.split("ref.func").pop().trim()}`;
            } else {
                $name = `$${$prop}_${block.begin}_${step.begin}`;
                inlineFunctions.push(`(func ${$name}\n${$func}\n)`);
            }
            chain = String(`
            (call $self.Reflect.apply<ext.ext.ext>${$exit}
                (ref.extern $self.Promise.prototype.${$prop}<ext>)
                ${chain.toString()}
                (call $self.Array.of<fun>ext (ref.func ${$name}))
            )`);
        }
        maskSet.update(block, chain);
    }
    wat = maskSet.restore();
    if (inlineFunctions.length) {
        wat = helpers.append(wat, inlineFunctions.join("\n\n"));
    }
    return wat;
}

const DATA_BLOCK_NAME = "data";
const SIZE_BLOCK_NAME = "data.size";
const VIEW_BLOCK_NAME = "data.view";
const GENERATE_DATA_VIEWER = (size, $name) => {
    return `
    (block ${$name}>
        (result externref)
        (global.set $wat4wasm (call $self.Array<>ext))
        
        (call $self.Reflect.set<ext.i32.i32>
            (global.get $wat4wasm) (i32.const 0) (i32.const ${size})
        )
        (global.set $wat4wasm
            (call $self.Reflect.construct<ext.ext>ext
                (ref.extern $self.Uint8Array<ext>)
                (global.get $wat4wasm)
            )
        )
        
        (if (i32.const ${size})
            (then
                (i32.const 0)
                (i64.load (i32.const 0))
                (block $copy
                    (i32.store (i32.const 0) (i32.const ${size}))
                    (loop $i--
                        (if (i32.load (i32.const 0))
                            (then   
                                (i32.store
                                    (i32.const 0)
                                    (i32.sub (i32.load (i32.const 0)) (i32.const 1))
                                )
                                (memory.init ${$name} 
                                    (i32.const 4) 
                                    (i32.load (i32.const 0)) 
                                    (i32.const 1)
                                )
                                (call $self.Reflect.set<ext.i32.i32>
                                    (global.get $wat4wasm)
                                    (i32.load (i32.const 0))
                                    (i32.load8_u (i32.const 4))
                                )
                                (br $i--)
                            )
                        )
                    )
                )
                (i64.store (; stack stack ;))
            )
        )
        (global.get $wat4wasm)
        (global.set $wat4wasm (null))
    )
    `;
};
function DATA (wat, WAT4WASM) {
    const maskSet = new helpers.MaskSet(wat);
    const externgetter = new Map();
    const segmentSizes = new Map();
    const sizeRequests = new Set();
    const viewRequests = new Set();
    while (maskSet.hasBlock(VIEW_BLOCK_NAME)) {
        const block = maskSet.lastBlockOf(VIEW_BLOCK_NAME);
        viewRequests.add(block);
        maskSet.mask(block);
    }
    while (maskSet.hasBlock(SIZE_BLOCK_NAME)) {
        const block = maskSet.lastBlockOf(SIZE_BLOCK_NAME);
        sizeRequests.add(block);
        maskSet.mask(block);
    }
    while (maskSet.hasBlock(DATA_BLOCK_NAME)) {
        const block = maskSet.lastBlockOf(DATA_BLOCK_NAME);
        const content = helpers.findQuotedText(block);
        maskSet.mask(block);
        if (helpers.hasProtocol(content) === false) {
            continue;
        }
        let {
            protocol, fullpath, directory,
            filename, basename, extension
        } = helpers.parseProtoPath(content);
        if (protocol === "wasm://") {
            const module_wat = `${basename}.wat`;
            const wasm_output = `${basename}.wasm`;
            const wat4wasm_out = `${basename}.wasm.wat`;
            const params = process.argv
                .filter(a => a.startsWith("--"))
                .filter(a => !a.startsWith("--input="))
                .filter(a => !a.startsWith("--output="))
                ;
            helpers.copyFile(fullpath, module_wat)
            const wat4wasm = process.argv[1];
            const nodejs = process.argv[0];
            const argv = Array.of(
                wat4wasm,
                `--input=${module_wat}`,
                `--output=${wasm_output}`,
                `--no-unlink`
            ).concat(params);
            helpers.spawnSync(nodejs, argv);
            const { data, size } = helpers.readFileAsHex(wasm_output);
            segmentSizes.set(block.$name, size);
            maskSet.update(block, block.replace(content, data));
            helpers.unlinkFile(module_wat);
            helpers.unlinkFile(wasm_output);
            helpers.unlinkFile(wat4wasm_out);
        }
        else if (protocol === "file://") {
            const { data, size } = helpers.readFileAsHex(fullpath);
            segmentSizes.set(block.$name, size);
            maskSet.update(block, block.replace(content, data));
        }
    }
    sizeRequests.forEach(block => {
        const size = segmentSizes.get(block.$name);
        const code = `(i32.const ${size})`;
        maskSet.update(block, code);
    });
    viewRequests.forEach(block => {
        block.id = helpers.referenceId();
        maskSet.update(block, block.id);
    });
    wat = maskSet.restore();
    let oninit = String();
    viewRequests.forEach(block => {
        if (externgetter.has(block.$name) === false) {
            const size = segmentSizes.get(block.$name);
            const code = GENERATE_DATA_VIEWER(size, block.$name);
            const growRequest = WAT4WASM_GROW_EXTERN_TABLE(wat);
            block.tableSetter = growRequest.generateSetter(code);
            wat = growRequest.modifiedRaw;
            oninit = `${oninit}\n\n${block.tableSetter}\n\n`;
            externgetter.set(
                block.$name,
                growRequest.getter.concat(` ;; ${block.$name}\n`)
            );
        }
    });
    viewRequests.forEach(block => {
        wat = wat.replaceAll(
            block.id, externgetter.get(block.$name)
        );
    });
    wat = APPEND_ON_EXTERN_READY(wat, oninit);
    return wat;
}

const IMPORT_BLOCK_NAME = "import";
const RAWBLOCK_IMPORT_CODE = (pathName, rawBlock) => `(import "${pathName.split(".").at(-2) || 'self'}" "${pathName.split(".").at(-1)}"  \t${rawBlock})`.replaceAll(" )", ")");
const FUNCTION_IMPORT_CODE = ($name) => {
    const namesig = $name.match(/\$(.[^<]*)<(.[^>]*)?>(.[^\s]*)?/).slice(1);
    const [pathName, inputs = "", outputs = ""] = namesig;
    const tagName = `func`;
    const longType = t => ({ ext: 'externref', fun: 'funcref' })[t] || t;
    const paramBlock = `(param${`.${inputs}`.split('.').map(longType).join(' ')})`;
    const resultBlock = `(result${`.${outputs}`.split('.').map(longType).join(' ')})`;
    return RAWBLOCK_IMPORT_CODE(pathName, `(${tagName} ${$name} ${paramBlock} ${resultBlock})`);
}
const GLOBAL_IMPORT_CODE = ($name) => {
    const namesig = $name.match(/\$(.[^<]*)(?:\<(.[^>]*)\>)?/)?.slice(1) || [];
    const [pathName = "self", type = "ext"] = namesig;
    const tagName = "global";
    const typeName = type.replace(`ext`, `externref`);
    return RAWBLOCK_IMPORT_CODE(pathName, `(${tagName} ${$name} ${typeName})`);
}
const GLOBAL_DEFINE_CODE = ($name) => {
    const [pathName = "self", type = "ext"] = helpers.nameSignatureofGlobal($name);
    const tagName = "global";
    const mutValue = t => `(mut ${({ ext: 'externref', fun: 'funcref' })[t] || t})`;
    const nilValue = t => `(${({ ext: 'ref.null extern', fun: 'ref.null func' })[t] || `${t}.const 0`})`;
    return `(${tagName} ${$name} ${mutValue(type)} ${nilValue(type)})`;
}
const PATH_WALKER_CODE = ($name) => {
    let descriptorKey;
    [$name, descriptorKey = "value"] = $name.split("/")
    const nameparts = $name.split("<").at(0).split("$").pop().split(".");
    const stepType = new Array(nameparts.length - 1).fill("ext");
    const type = $name.split(">").at(0).split("<").pop() || "ext";
    let pathWalker = `(global.get $${nameparts[0]})`;
    let currentKey;
    stepType.push(type);
    stepType.reverse().pop();
    nameparts.reverse().pop();
    let stepCount = nameparts.length;
    if (descriptorKey !== "value") {
        stepCount = stepCount - 1;
    }
    while (stepCount--) {
        currentKey = nameparts.pop();
        pathWalker = String(`
        (call $self.Reflect.get<ext.ext>${stepType.pop()}
            ${pathWalker} 
            (text "${currentKey}") ;; ${currentKey}
        )`).trim();
    }
    if (descriptorKey !== "value") {
        currentKey = nameparts.pop();
        pathWalker = String(`
        (call $self.Reflect.get<ext.ext>ext
            (call $self.Reflect.getOwnPropertyDescriptor<ext.ext>ext
                ${pathWalker} 
                (text "${currentKey}") ;; ${currentKey}
            )
            (text "${descriptorKey}") ;; ${descriptorKey}
        )`).trim();
    }
    return String(`
    ${pathWalker}
    `);
}
function IMPORT (wat, WAT4WASM) {
    const maskSet = new helpers.MaskSet(wat);
    const selfSet = new Set();
    const imports = new Array();
    const globals = new Array();
    const oninits = new Array();
    while (maskSet.hasBlock(IMPORT_BLOCK_NAME)) {
        const wrapper = maskSet.lastBlockOf(IMPORT_BLOCK_NAME);
        const $name = helpers.parseFirstBlock(wrapper).$name;
        if ($name && $name.startsWith("$self")) {
            if (selfSet.has($name) === false) {
                selfSet.add($name);
            }
        }
        maskSet.mask(wrapper);
    }
    while (maskSet.hasBlock("global.get")) {
        const global = maskSet.lastBlockOf("global.get");
        const $name = global.$name;
        maskSet.mask(global);
        maskSet.update(global, `(global.get ${$name})`);
        if ($name && $name.startsWith("$self")) {
            if (selfSet.has($name) === false) {
                selfSet.add($name);
                const [pathName = "self", type = "ext"
                ] = helpers.nameSignatureofGlobal($name);
                const nameparts = pathName.split(".");
                /**
                 * previous logic is based on direct import for
                 * short paths but this is unnecessary.. just set
                 * global value in the start function to gathering
                 * more simple import segment. 
                 */
                //if (nameparts.length <= 3) {
                if (["$self", "$self.String.fromCharCode"].includes($name)) {
                    imports.push(GLOBAL_IMPORT_CODE($name));
                }
                else if (globals.includes($name) === false) {
                    globals.push(GLOBAL_DEFINE_CODE($name));
                    const walker = PATH_WALKER_CODE($name, global.descriptorKey);
                    const setter = `(global.set ${$name} ${walker})`;
                    oninits.push({ setter, name: $name.substring(1), type: 'global' });
                }
            }
        }
    }
    while (maskSet.hasBlock("call")) {
        const caller = maskSet.lastBlockOf("call");
        const $name = caller.$name;
        if ($name && $name.startsWith("$self")) {
            if (selfSet.has($name) === false) {
                selfSet.add($name);
                imports.push(FUNCTION_IMPORT_CODE($name));
            }
        }
        maskSet.mask(caller);
    }
    wat = maskSet.restore();
    imports.forEach(code => {
        if (wat.includes(code) === false) {
            wat = helpers.prepend(wat, code);
        }
    });
    globals.forEach(code => {
        if (wat.includes(code) === false) {
            wat = helpers.append(wat, code);
        }
    });
    oninits.forEach(init => {
        const header = `block $${init.type}/${init.name}`;
        if (wat.includes(header) === false) {
            const code = String(`(${header}\n${init.setter}\n)`);
            wat = APPEND_ON_TEXT_READY(wat, code);
        }
    });
    return wat;
}

const INCLUDE_BLOCK_NAME = "include";
function INCLUDE (wat, WAT4WASM) {
    while (helpers.hasBlock(wat, INCLUDE_BLOCK_NAME)) {
        const block = helpers.lastBlockOf(wat, INCLUDE_BLOCK_NAME);
        const path = helpers.findQuotedText(block);
        wat = block.replacedRaw(
            helpers.readFileAsText(path)
        );
    }
    return wat;
}

const NEW_BLOCK_NAME = "new";
function NEW (wat) {
    while (helpers.hasBlock(wat, NEW_BLOCK_NAME)) {
        const block = helpers.lastBlockOf(wat, NEW_BLOCK_NAME);
        const $name = block.$name;
        const param = $name.split(">").at(0).split("<").at(1) || "";
        const $constructor = `(ref.extern $self.${$name.substring(1)}<ext>)`;
        const $arguments = block.replace(`(new ${$name}`, `(array $of<${param}>ext`);
        const $reflect = `(reflect $construct<ext.ext>ext\n${$constructor}\n${$arguments}\n)`;
        wat = block.replacedRaw($reflect);
    }
    return wat;
}

const REF_EXTERN_BLOCK_NAME = "ref.extern";
const FIXNAME_SELF_PATH = ($name, descriptorKey) => {
    if ($name.startsWith("$self") === false) {
        $name = `$self.${$name.substring(1)}`;
    }
    if ($name.endsWith(">") === false) {
        if (descriptorKey === "value") {
            $name = `${$name}<ext>`;
        }
    }
    return $name;
};
function REF_EXTERN (wat, WAT4WASM) {
    const externs = new Map();
    const getters = new Map();
    const maskSet = new helpers.MaskSet(wat);
    while (maskSet.hasBlock(REF_EXTERN_BLOCK_NAME)) {
        const block = maskSet.lastBlockOf(REF_EXTERN_BLOCK_NAME);
        const $name = FIXNAME_SELF_PATH(block.$name, block.descriptorKey);
        if (externs.has($name) === false) {
            externs.set($name, block.descriptorKey);
        }
        maskSet.mask(block);
    }
    wat = maskSet.restore();
    let oninit = String();
    externs.forEach((dKey, $name) => {
        const pathWalker = PATH_WALKER_CODE($name);
        const growExtern = WAT4WASM_GROW_EXTERN_TABLE(wat);
        const __getter__ = growExtern.getter.concat(` ;; ${$name}\n`);
        const __setter__ = growExtern.generateSetter(pathWalker);
        wat = growExtern.modifiedRaw;
        oninit = `${oninit}\n\n(block ${$name}\n${__setter__})\n`;
        getters.set($name, __getter__);
    });
    while (helpers.hasBlock(wat, REF_EXTERN_BLOCK_NAME)) {
        const block = helpers.lastBlockOf(wat, REF_EXTERN_BLOCK_NAME);
        const $name = FIXNAME_SELF_PATH(block.$name, block.descriptorKey);
        wat = block.replacedRaw(getters.get($name));
    }
    if (oninit.trim()) {
        wat = APPEND_ON_TEXT_READY(wat, oninit);
    }
    return wat;
}

const REF_FUNC_BLOCK_NAME = "ref.func";
function REF_FUNC (wat, WAT4WASM) {
    const maskSetElem = new helpers.MaskSet(wat);
    const elemSegments = new Array();
    const needReference = new Set();
    while (maskSetElem.hasBlock("elem")) {
        const block = maskSetElem.lastBlockOf("elem");
        const $name = block.$name;
        if (WAT4WASM.WAT4WASM_$NAME !== $name) {
            elemSegments.push(block.toString());
        }
        maskSetElem.mask(block);
    }
    const maskSetRef = new helpers.MaskSet(wat);
    while (maskSetRef.hasBlock(REF_FUNC_BLOCK_NAME)) {
        const block = maskSetRef.lastBlockOf(REF_FUNC_BLOCK_NAME);
        const $name = block.$name
        if (WAT4WASM.WAT4WASM_$NAME !== $name) {
            if (elemSegments.some(seg => seg.includes($name)) === false) {
                if (needReference.has($name) === false) {
                    needReference.add($name);
                }
            }
        }
        maskSetRef.mask(block);
    }
    wat = maskSetRef.restore();
    needReference.forEach($name => {
        wat = WAT4WASM_REFERENCE_FUNC_ELEMENT(wat, $name);
    });
    return wat;
}


function REPLACE_ALL (wat) {
    return wat
        .replaceAll("(self)", "(global.get $self)")
        .replaceAll("(null)", "(ref.null extern)")
        .replaceAll("(func)", "(ref.null func)")
        .replaceAll("(this)", "(local.get 0)")
        .replaceAll("(array)", "(call $self.Array<>ext)")
        .replaceAll("(NaN)", "(ref.extern $self.NaN<ext>)")
        .replaceAll("(nan)", "(f32.const nan)")
        .replaceAll("(true)", "(i32.const 1)")
        .replaceAll("(false)", "(i32.const 0)")
        .replaceAll("(undefined)", "(ref.extern $self.undefined<ext>)")
        .replaceAll("(object)", "(call $self.Object<>ext)")
        .replaceAll("(string)", "(call $self.String<>ext)")
        .replaceAll("(console $", "(call $self.console.")
        .replaceAll("(reflect $", "(call $self.Reflect.")
        .replaceAll("(bigint $", "(call $self.BigInt.")
        .replaceAll("(number $", "(call $self.Number.")
        .replaceAll("(math $", "(call $self.Math.")
        .replaceAll("(string $", "(call $self.String.")
        .replaceAll("(object $", "(call $self.Object.")
        .replaceAll("(array $", "(call $self.Array.")
        .replaceAll("(grow $", "(table.grow $")
        .replaceAll("(url $", "(call $self.URL.")
        .replaceAll("(self $", "(ref.extern $self.")
        .replaceAll(" mut ext)", " (mut externref) (null))")
        .replaceAll(" mut fun)", " (mut funcref) (func))")
        .replaceAll(" mut vec)", " (mut v128) (v128.const i32x4 0 0 0 0))")
        .replaceAll(" fun)", " funcref)")
        .replaceAll(" ext)", " externref)")
        .replaceAll(" != null)", ") (ref.is_null) (i32.eqz)")
        .replaceAll(" == null)", ") (ref.is_null)")
        .replaceAll(" == 0)", ") (i32.eqz)")
        .replaceAll(" != 0)", ") (i32.const 0) (i32.ne)")
        .replaceAll(" == 1)", ") (i32.const 1) (i32.eq)")
        .replaceAll(" != 1)", ") (i32.const 1) (i32.ne)")
        .replaceAll(" == true)", ") (i32.const 1) (i32.eq)")
        .replaceAll(" == false)", ") (i32.eqz)")
        .replaceAll(" == nan)", ") (f32.const nan) (f32.eq)")
        .replaceAll(" != nan)", ") (f32.const nan) (f32.ne)")
        .replaceAll(" != NaN)", ") (NaN) (object $is<ext.ext>i32) (i32.eqz)")
        .replaceAll(" == NaN)", ") (NaN) (object $is<ext.ext>i32)")
        .replaceAll(" != undefined)", ") (undefined) (object $is<ext.ext>i32) (i32.eqz)")
        .replaceAll(" == undefined)", ") (undefined) (object $is<ext.ext>i32)")
        .replaceAll(/ mut\s+(i32|f32|i64|f64)\)/g, ` (mut $1) ($1.const 0))`)
        .replaceAll(/\<[A-Z](.[^>]*)\>/g, "externref")
        .replaceAll(/\(l(get|set|tee)(\s)/g, `(local.$1$2`)
        .replaceAll(/\(g(get|set)(\s)/g, `(global.$1$2`)
        .replaceAll(/\(t(get|set)(\s)/g, `(table.$1$2`)
        .replaceAll(/(i32|f32|i64|f64|fun|ext)\((\+|\-|)\s*([0-9\.]+)\)/g, `($1.const $2$3)`)
        .replaceAll(/\((.*)\.(set|tee)\s+([\+|\-])+\s+(\$.*)\s*\)/g, "($1.$2 $4 (i32.add ($1.get $4) (i32.const $31)))")
        .replaceAll(/\(apply(?:\.*)(i32|f32|i64|f64|fun|ext|)(\s*)/g, `(call $self.Reflect.apply<ext.ext.ext>$1 $2`)
        .replaceAll(/\(main(\s+)(\$.[^\s]*)(\s)/g, `(start$1$2)\n\n(func$1$2$3`)
        ;
}

const START_BLOCK_NAME = "start";
function START (wat, WAT4WASM) {
    let startCalls = [];
    let removedWat = wat;
    while (helpers.hasBlock(removedWat, START_BLOCK_NAME)) {
        let block = helpers.lastBlockOf(removedWat, START_BLOCK_NAME);
        removedWat = block.removedRaw();
        if (block.includes(WAT4WASM.WAT4WASM_$NAME) === false) {
            startCalls.push(block);
        }
    }
    if (startCalls.length > 0) {
        wat = removedWat;
        let $wat4func = helpers.lastBlockOf(wat, "func", { $name: WAT4WASM.WAT4WASM_$NAME });
        let funcblock = $wat4func.toString();
        const appends = startCalls.filter(start => {
            let $name = `${start.$name}`;
            let $call = `(call ${$name})`;
            if (helpers.hasBlock(funcblock, "call", { $name }) === false) {
                funcblock = helpers.append(funcblock, $call);
                return true;
            }
        });
        if (appends.length) {
            wat = $wat4func.replacedRaw(funcblock);
        }
        wat = helpers.append(wat, WAT4WASM.WAT4WASM_START);
    }
    return wat;
}

const STRING_BLOCK_NAME = "string";
function STRING (wat) {
    while (helpers.hasBlock(wat, STRING_BLOCK_NAME)) {
        let oldBlock = helpers.lastBlockOf(wat, STRING_BLOCK_NAME);
        const string = helpers.findQuotedText(oldBlock);
        const ccodes = helpers.encodeString(string);
        if (ccodes.length === 0) {
            wat = oldBlock.replacedRaw(`
                (reflect $apply<ext.ext.ext>ext
                    (global.get $self.String.fromCharCode) 
                    (self)
                    (self)
                )
            `);
        }
        else if (ccodes.length === 1) {
            wat = oldBlock.replacedRaw(`
                (reflect $apply<ext.ext.ext>ext
                    (global.get $self.String.fromCharCode)
                    (self)
                    (array $of<i32>ext (i32.const ${string.charCodeAt(0)})) ;; "${string}"
                )
            `);
        }
        else {
            wat = oldBlock.replacedRaw(`
                (block (; "${helpers.abstract(string)}" ;)
                    (result externref)
                    (global.set $wat4wasm (call $self.Array<>ext))
                    
                    ${ccodes
                    .map((c, i) => `(global.get $wat4wasm) (i32.const ${i}) (i32.const ${c})`)
                    .map((args) => `(call $self.Reflect.set<ext.i32.i32> ${args})`)
                    .join("\n")}
    
                    (call $self.Reflect.apply<ext.ext.ext>ext
                        (global.get $self.String.fromCharCode) 
                        (ref.null extern) 
                        (global.get $wat4wasm)
                    ) 
                    ;; stacked
    
                    (global.set $wat4wasm (null)) 
                    ;; cleared
                )
            `);
        }
    }
    return wat;
}

const TEXT_BLOCK_NAME = "text";
const TEXT_ONINIT_BLOCK = (offset, length, setter) => String(
    `
    (block $decodeText/${offset}:${length}
        (local.set $viewAt (i32.const 0))
        (local.set $offset (i32.const ${offset}))
        (local.set $length (i32.const ${length}))
        (local.set $arguments (call $self.Array<>ext))
            
        (call $self.Reflect.set<ext.i32.i32>
            (local.get $arguments) (i32.const 0) (local.get $length)
        )
        (local.set $arrayBufferView
            (call $self.Reflect.construct<ext.ext>ext
                (local.get $Uint8Array)
                (local.get $arguments)
            )
        )
        (loop $length--
            (if (local.get $length)
                (then
                    (memory.init $wat4wasm 
                        (i32.const 0) 
                        (local.get $offset) 
                        (i32.const 1)
                    )
                    (call $self.Reflect.set<ext.i32.i32>
                        (local.get $arrayBufferView)
                        (local.get $viewAt)
                        (i32.load8_u (i32.const 0))
                    )
                    (local.set $viewAt (i32.add (local.get $viewAt) (i32.const 1)))
                    (local.set $offset (i32.add (local.get $offset) (i32.const 1)))
                    (local.set $length (i32.sub (local.get $length) (i32.const 1)))
                    (br $length--)
                )
            )
        )
        (local.set $arguments (call $self.Array<>ext))
        (call $self.Reflect.set<ext.i32.ext>
            (local.get $arguments)
            (i32.const 0)
            (local.get $arrayBufferView)
        )
        ${setter}
    )    
`).trim();
function TEXT (wat, WAT4WASM) {
    const maskSet = new helpers.MaskSet(wat);
    const textBlocks = new Array();
    while (maskSet.hasBlock(TEXT_BLOCK_NAME)) {
        let block = maskSet.lastBlockOf(TEXT_BLOCK_NAME);
        maskSet.mask(block);
        textBlocks.push(block);
    }
    wat = maskSet.restore();
    textBlocks.forEach(block => {
        const text = helpers.findQuotedText(block);
        const view = helpers.encodeText(text);
        const dataRequest = WAT4WASM_ALLOC_DATA_BUFFER(wat, view.buffer);
        block.dataOffset = dataRequest.offset;
        block.viewLength = view.length;
        block.strPreview = helpers.abstract(text);
        wat = dataRequest.modifiedRaw;
    });
    textBlocks.forEach(block => {
        const growRequest = WAT4WASM_GROW_EXTERN_TABLE(wat);
        block.tableGetter = growRequest.getter.concat(`;; ${block.strPreview} \n`);
        block.tableSetter = growRequest.generateSetter(`
        (call $self.Reflect.apply<ext.ext.ext>ext
            (local.get $textDecoder.decode)
            (local.get $textDecoder)
            (local.get $arguments) ;; ${block.strPreview}
        )`).trim();
        wat = growRequest.modifiedRaw;
    });
    textBlocks.forEach(block => {
        wat = wat.replaceAll(block.toString(), block.tableGetter)
    });
    const oninit = textBlocks.map(block =>
        TEXT_ONINIT_BLOCK(
            block.dataOffset,
            block.viewLength, block.tableSetter
        )
    ).join("\n");
    wat = APPEND_ON_INIT(wat, oninit);
    return wat;
}

let WAT4WASM_$NAME = `$wat4wasm`;
let WAT4WASM_FUNC = String(`
    (func $wat4wasm 
        (local $textDecoder externref)
        (local $textDecoder.decode externref)
        (local $Uint8Array externref)
        (local $arguments externref)
        (local $arrayBufferView externref)
        (local $viewAt i32)
        (local $offset i32)
        (local $length i32)
        (block $prepare
            (local.set $textDecoder
                (call $self.Reflect.construct<ext.ext>ext
                    (call $self.Reflect.get<ext.ext>ext
                        (self) 
                        (string "TextDecoder")
                    )
                    (self)
                )
            )
            (local.set $textDecoder.decode
                (call $self.Reflect.get<ext.ext>ext
                    (local.get $textDecoder)
                    (string "decode")
                )
            )
            (local.set $Uint8Array
                (call $self.Reflect.get<ext.ext>ext
                    (self) 
                    (string "Uint8Array")
                )
            )
        )
        ;;secure zero heap for memory.init
        (i32.const 0)
        (i32.load (i32.const 0))
        ;; offset and value stacked now 
        (block $oninit)
        (block $ontextready)
        (block $onexternready)
        
        ;; restore zero heap value
        (i32.store (; stack stack ;))
        (nop)
    )
`);
let WAT4WASM_GLOBAL = String(
    `(global $wat4wasm (mut externref) (ref.null extern))`
);
let WAT4WASM_TABLE = (size = 1) => String(
    `(table $wat4wasm ${size} externref)`
);
let WAT4WASM_DATA = (buff = "0000") => String(
    `(data $wat4wasm "${Buffer.from(buff).toString("hex").replaceAll(/(..)/g, `\\$1`)}")`
);
let WAT4WASM_ELEM = String(
    `(elem $wat4wasm declare func)`
);
let WAT4WASM_MEMORY = String(
    `(memory $wat4wasm 1)`
);
let WAT4WASM_START = String(
    `(start $wat4wasm)`
);
const WAT4WASM_BLOCKS = {
    global: WAT4WASM_GLOBAL,
    table: WAT4WASM_TABLE(1),
    elem: WAT4WASM_ELEM,
    func: WAT4WASM_FUNC,
    data: WAT4WASM_DATA(),
};
function FUNC_WAT4WASM(wat) {
    return helpers.lastBlockOf(wat, "func", { $name: WAT4WASM_$NAME });
}
function ELEM_WAT4WASM(wat) {
    const block = helpers.lastBlockOf(wat, "elem", { $name: WAT4WASM_$NAME });
    return block && Object.assign(block, {
        isInitial: helpers.generateId(block) === helpers.generateId(WAT4WASM_ELEM)
    });
}
function MEMORY_WAT4WASM(wat) {
    return helpers.lastBlockOf(wat, "memory", { $name: WAT4WASM_$NAME });
}
function GLOBAL_WAT4WASM(wat) {
    return helpers.lastBlockOf(wat, "global", { $name: WAT4WASM_$NAME });
}
function START_WAT4WASM(wat) {
    return helpers.lastBlockOf(wat, "start", { $name: WAT4WASM_$NAME });
}
function FUNC_WAT4WASM_NOBLOCKS(wat) {
    const maskSet = new helpers.MaskSet(FUNC_WAT4WASM(wat));
    maskSet.remove(maskSet.lastBlockOf("block", { name: "onexternready" }));
    maskSet.remove(maskSet.lastBlockOf("block", { name: "ontextready" }));
    maskSet.remove(maskSet.lastBlockOf("block", { name: "oninit" }));
    maskSet.remove(maskSet.lastBlockOf("block", { name: "prepare" }));
    return maskSet.restore();
}
function FUNC_WAT4WASM_BLOCK_ONINIT(wat) {
    const wat4func = FUNC_WAT4WASM(wat);
    const blockoninit = helpers.lastBlockOf(wat4func, "block", { name: "oninit" });
    const $blockoninit = helpers.parseBlockAt(wat, wat4func.begin + blockoninit.begin);
    return $blockoninit;
}
function FUNC_WAT4WASM_BLOCK_ONTEXTREADY(wat) {
    const wat4func = FUNC_WAT4WASM(wat);
    const ontextready = helpers.lastBlockOf(wat4func, "block", { name: "ontextready" });
    const $ontextready = helpers.parseBlockAt(wat, wat4func.begin + ontextready.begin);
    return $ontextready;
}
function FUNC_WAT4WASM_BLOCK_ONEXTERNREADY(wat) {
    const wat4func = FUNC_WAT4WASM(wat);
    const onexternready = helpers.lastBlockOf(wat4func, "block", { name: "onexternready" });
    const $onexternready = helpers.parseBlockAt(wat, wat4func.begin + onexternready.begin);
    return $onexternready;
}
function APPEND_ON_INIT(wat, block) {
    const oninitblock = FUNC_WAT4WASM_BLOCK_ONINIT(wat);
    if (oninitblock.includes(block.toString())) {
        return wat;
    }
    wat = oninitblock.replacedRaw(
        helpers.append(oninitblock, block)
    );
    return wat;
}
function APPEND_ON_TEXT_READY(wat, block) {
    const ontextready = FUNC_WAT4WASM_BLOCK_ONTEXTREADY(wat);
    if (ontextready.hasBlock("block",
        { $name: helpers.firstBlockOf(block, "block")?.$name }
    ) === false && !ontextready.includes(block.trim())) {
        return ontextready.replacedRaw(
            helpers.append(ontextready, block)
        );
    }
    return wat;
}
function APPEND_ON_EXTERN_READY(wat, block) {
    const onexternready = FUNC_WAT4WASM_BLOCK_ONEXTERNREADY(wat);
    if (onexternready.includes(block.toString())) {
        return wat;
    }
    wat = onexternready.replacedRaw(
        helpers.append(onexternready, block)
    );
    return wat;
}
function TABLE_WAT4WASM(wat) {
    const wat4table = helpers.lastBlockOf(wat, "table", { $name: WAT4WASM_$NAME });
    const lastIndex = parseInt(wat4table.toString().match(/\s(\d+)/).pop());
    return wat4table && Object.assign(wat4table, {
        lastIndex, isInitial: lastIndex === 1
    })
}
function WAT4WASM_GROW_EXTERN_TABLE(wat) {
    const wat4table = TABLE_WAT4WASM(wat);
    const lastIndex = wat4table.lastIndex;
    return {
        index: lastIndex,
        getter: `(table.get ${WAT4WASM_$NAME} (i32.const ${lastIndex}))`,
        generateSetter: value => `(table.set ${WAT4WASM_$NAME} (i32.const ${lastIndex}) ${value.toString()})`,
        modifiedRaw: wat4table.replacedRaw(WAT4WASM_TABLE(lastIndex + 1))
    };
}
function WAT4WASM_REFERENCE_FUNC_ELEMENT(wat, $name) {
    const $wat4elem = ELEM_WAT4WASM(wat);
    const _wat4elem = $wat4elem.toString();
    if (_wat4elem.includes($name) === false) {
        wat = $wat4elem.replacedRaw(_wat4elem
            .substring(0, _wat4elem.lastIndexOf(")"))
            .concat(` ${$name}`)
            .concat(")")
        );
    }
    return wat;
}
function DATA_WAT4WASM(wat) {
    const block = helpers.lastBlockOf(wat, "data", { $name: WAT4WASM_$NAME });
    const strhex = helpers.findQuotedText(block);
    const buffer = Buffer.from(strhex.replaceAll(/[^a-f0-9A-F]/g, ""), "hex");
    return Object.assign(block, {
        buffer: buffer,
        offset: buffer.byteLength,
        isInitial: buffer.byteLength === 4
    });
}
function WAT4WASM_ALLOC_DATA_BUFFER(wat, buffer) {
    const new_data = Buffer.from(buffer);
    const all_data = DATA_WAT4WASM(wat);
    let offset = all_data.buffer.indexOf(new_data);
    let modifiedRaw = wat;
    if (offset < 1) {
        offset = all_data.offset;
        all_data.buffer.writeUint32LE(offset + new_data.byteLength);
        modifiedRaw = all_data.replacedRaw(WAT4WASM_DATA(Buffer.concat([all_data.buffer, new_data])));
    }
    return {
        offset,
        modifiedRaw,
        isRawModified: modifiedRaw.toString() !== wat.toString()
    };
}
function W4W (wat) {
    let i = 31, raw;
    if (helpers.hasBlock(wat, "memory") === false) {
        WAT4WASM_BLOCKS.memory = WAT4WASM_MEMORY;
    }
    for (const BLOCK_NAME in WAT4WASM_BLOCKS) {
        if (wat.includes(`(${BLOCK_NAME} ${WAT4WASM_$NAME}`)) {
            continue;
        }
        if (i === 31) console.log("")
        console.log(`🦋 appending element --> \x1b[${i++}m(${BLOCK_NAME} ${WAT4WASM_$NAME}) ...)\x1b[0m`);
        raw = WAT4WASM_BLOCKS[BLOCK_NAME].replaceAll("$wat4wasm", WAT4WASM_$NAME);
        wat = helpers.append(wat, raw);
    }
    if (i !== 31) console.log("")
    return wat;
}function FUNC_WAT4WASM_START_CALLS(wat) {
    let $call;
    const calls = [];
    const maskSet = new helpers.MaskSet(
        FUNC_WAT4WASM_NOBLOCKS(wat)
    );
    while ($call = maskSet.lastBlockOf("call")) {
        if (calls.includes($call.$name) === false) {
            calls.push($call.$name);
        }
        maskSet.mask($call);
    }
    return calls;
}
function clean (wat) {
    let block;
    block = FUNC_WAT4WASM_BLOCK_ONEXTERNREADY(wat);
    if (!block.hasAnyBlock) { wat = block.removedRaw(); }
    block = FUNC_WAT4WASM_BLOCK_ONTEXTREADY(wat);
    if (!block.hasAnyBlock) { wat = block.removedRaw(); }
    block = FUNC_WAT4WASM_BLOCK_ONINIT(wat);
    if (!block.hasAnyBlock) {
        wat = block.removedRaw();
        let $starts = FUNC_WAT4WASM_START_CALLS(wat);
        if ($starts.length === 1) {
            wat = START_WAT4WASM(wat)?.removedRaw();
            if ($starts.length === 1) {
                wat = helpers.append(wat, `(start ${$starts.pop()})`);
            }
        }
        let $func = FUNC_WAT4WASM(wat);
        if ($func) {
            wat = $func.removedRaw();
        }
    }
    block = ELEM_WAT4WASM(wat);
    if (block.isInitial) { wat = block.removedRaw(); }
    block = TABLE_WAT4WASM(wat);
    if (block.isInitial) { wat = block.removedRaw(); }
    block = DATA_WAT4WASM(wat);
    if (block.isInitial) { wat = block.removedRaw(); }
    if (false === helpers.hasBlock(wat, "global.get", { $name: WAT4WASM_$NAME }) &&
        false === helpers.hasBlock(wat, "global.set", { $name: WAT4WASM_$NAME })) {
        wat = GLOBAL_WAT4WASM(wat).removedRaw();
    }
    block = MEMORY_WAT4WASM(wat);
    if (block && (helpers.containsMemoryOperation(wat) === false)) {
        wat = block.removedRaw();
    }
    const maskSet = new helpers.MaskSet(wat);
    const imports = new Array();
    while (block = maskSet.lastBlockOf("import")) {
        block.$name = helpers.parseFirstBlock(block).$name;
        imports.push(block);
        maskSet.remove(block);
    }
    wat = maskSet.restore();
    wat = helpers.prepend(wat,
        imports
            .filter(b => new RegExp(`\\${b.$name}\(\\s|\\)\)`).test(wat))
            .sort((a, b) => helpers.generateId(a) - helpers.generateId(b))
            .map(b => b.toString())
            .join("\n")
    );
    return wat;
}


async function processCLI(compileCallback, PROCESS = process) {
    console.log("\x1b[31m")
    // Argument Parsing Logic
    const args = PROCESS.argv.slice(2);
    const config = {
        inputFile: null,
        outputFile: null,
        wat2wasmPath: null,
        unlinkWat4FileIfCompilationSuccess: true,
        windowtagName: "",
        defaultTagName: "🦋",
        keepChromeGlobal: false,
        keepHTMLDocument: false,
        keepWindowTagName: false,
        keepWindowObjects: false,
        keepFaviconRequest: false,
        generateWASMFromHEXString: true,
        generateWASMFromNumberArray: false,
        consoleLogInstance: false,
        faviconLinkHref: "data:null",
        printOnly: false,
        passthroughArgs: [],
    };
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith("--output=")) {
            config.outputFile = arg.split("=")[1];
        } else if (arg.startsWith("--input=")) {
            config.inputFile = arg.split("=")[1];
        } else if (arg.startsWith("--wat2wasm=")) {
            config.wat2wasmPath = arg.split("=")[1];
        } else if (arg.startsWith("--tag=")) {
            config.windowtagName = arg.split("=")[1];
        } else if (arg === "--print-only") {
            config.printOnly = true;
        } else if (arg === "--wasm-from-numbers-array") {
            config.generateWASMFromNumberArray = true;
            config.generateWASMFromHEXString = false;
        } else if (arg === "--wasm-from-hex-string") {
            config.generateWASMFromHEXString = true;
            config.generateWASMFromNumberArray = false;
        } else if (arg === "--untouched-window") {
            config.keepHTMLDocument = true;
            config.keepChromeGlobal = true;
            config.keepWindowObjects = true;
            config.keepFaviconRequest = true;
            config.windowtagName &&= "";
        } else if (arg === "--log-instance") {
            config.consoleLogInstance = true;
        } else if (arg === "--keep-window") {
            config.keepWindowObjects = true;
        } else if (arg === "--keep-chrome-global") {
            config.keepChromeGlobal = true;
        } else if (arg === "--keep-document") {
            config.keepHTMLDocument = true;
        } else if (arg === "--keep-favicon") {
            config.keepFaviconRequest = true;
        } else if (arg === "--no-unlink") {
            config.unlinkWat4FileIfCompilationSuccess = false;
        } else if (arg.startsWith("-")) {
            // Collect flags to pass to wat2wasm
            config.passthroughArgs.push(arg);
        } else {
            if (!config.inputFile) {
                config.inputFile = arg;
            } else {
                console.warn(`Warning: Ignoring extra argument '${arg}'`);
            }
        }
    }
    if (!config.inputFile) {
        console.error("Error: Input file required! Usage: wat4wasm <input.wat> [options]");
        PROCESS.exit(1);
    }
    const isJSTarget = config.outputFile?.endsWith(".js");
    const isHTMLTarget = config.outputFile?.endsWith(".html");
    if (isHTMLTarget || isJSTarget) {
        config.outputFile = config.outputFile.substring(
            0, config.outputFile.lastIndexOf(".")
        ).concat(".wat");
    }
    // Default output file if not specified (and not printing only)
    if (!config.outputFile && !config.printOnly) {
        config.outputFile = config.inputFile.replace(/\.wat$/, "-output.wat");
    }
    try {
        console.log(`\x1b[0m\x1b[33m🚀 Wat4Wasm: Processing ${config.inputFile}...\x1b[0m`);
        if (!fs.existsSync(config.inputFile)) {
            throw new Error(`Input file not found: ${config.inputFile}`);
        }
        const rawCode = fs.readFileSync(config.inputFile, "utf8");
        // 2. Call the provided compile function
        const compiled = await compileCallback(rawCode);
        console.log("\x1b[0m")
        // 3. Handle Output
        if (config.printOnly) {
            console.log("\x1b[0m\x1b[33m--- Compiled Output ---");
            console.log(compiled);
            console.log("-----------------------\x1b[0m");
            return;
        }
        // Write compiled WAT (or temp WAT for WASM target)
        let watFile = config.outputFile;
        let wasmFile = config.outputFile.substring(
            0, config.outputFile.lastIndexOf(".")
        ).concat(".wasm");
        const isWasmTarget = isJSTarget || isHTMLTarget || config.outputFile.endsWith(".wasm") || config.wat2wasmPath;
        if (isWasmTarget && config.outputFile.endsWith(".wasm")) {
            // If target is WASM, write WAT to a temp file
            watFile = config.outputFile + ".wat";
        }
        fs.writeFileSync(watFile, compiled);
        console.log(`\x1b[0m\x1b[36m✅ WAT Written to: ${watFile}\n`);
        // Run wat2wasm if requested
        if (config.wat2wasmPath || isHTMLTarget || isJSTarget) {
            console.log(`\x1b[0m\x1b[32m🔨 Running wat2wasm...`);
            // If user explicitly set .wasm output but output file was .wat? 
            // The logic above sets wasmFile = config.outputFile.
            // If config.outputFile was "out.wat", then we overwrite it with "out.wasm"? 
            // Standard wat2wasm behavior takes -o <file>.
            // Our config.outputFile came from --output.
            const cmdArgs = [watFile, ...config.passthroughArgs, "--output", wasmFile];
            console.log(`\x1b[0m\x1b[32m   Command: ${config.wat2wasmPath} ${cmdArgs.join(" ")}\n`);
            const result = spawnSync(config.wat2wasmPath, cmdArgs, { stdio: "inherit" });
            if (result.status === 0) {
                console.log(`\x1b[0m\x1b[35m🎉 WASM Build Successful: ${wasmFile}`);
                if (config.unlinkWat4FileIfCompilationSuccess && watFile !== wasmFile) {
                    try { fs.unlinkSync(watFile); } catch (e) { }
                }
                if (isJSTarget || isHTMLTarget) {
                    const wasmhex = fs.readFileSync(wasmFile, "hex");
                    let extension = "";
                    let filecontent = "";
                    if (isJSTarget) {
                        let wasmGenerator = ``;
                        if (config.generateWASMFromHEXString && !config.generateWASMFromNumberArray) {
                            wasmGenerator = `Uint8Array.from(/${wasmhex}/.toString().match(/[a-f0-9]{2}/g).map(h => parseInt(h, 16)))`;
                        }
                        else if (!config.generateWASMFromHEXString && config.generateWASMFromNumberArray) {
                            wasmGenerator = `Uint8Array.of(${wasmhex.toString().match(/[a-f0-9]{2}/g).map(h => parseInt(h, 16))})`;
                        }
                        extension = "js";
                        filecontent = `
                            const view = ${wasmGenerator};
                            let wasm = view.buffer;
                            
                            wasm.module = null;
                            wasm.instances = new Array;
                            
                            const compile = async () => WebAssembly.compile(wasm).then(m => {
                                wasm.module = m;
                                return wasm;
                            });
                            
                            const instantiate = async () => WebAssembly.instantiate(wasm.module, self).then(i => {
                                wasm.instances.push(i);    
                                return i;
                            });
                            
                            wasm.spawn = async imports => {
                                if (wasm.module instanceof WebAssembly.Module === false) {
                                    Object.assign(self, Object(imports));
                                    return compile().then(() => instantiate());
                                } 
                                return instantiate();
                            };
                            
                            default wasm;
                        `;
                    }
                    else {
                        extension = "html";
                        const thenCalls = [];
                        if (config.consoleLogInstance) {
                            thenCalls.push(`console.warn(wasm)`);
                        }
                        if (!config.keepHTMLDocument) {
                            thenCalls.push(`Array.from(document.children).forEach(i => i.remove())`);
                        }
                        if (!config.keepChromeGlobal && !config.keepWindowObjects) {
                            thenCalls.push(`self.chrome && (self.chrome = self)`)
                        }
                        const windowTag = config.windowtagName || config.defaultTagName;
                        if ((!config.keepWindowTagName && !config.keepWindowObjects) || config.windowtagName) {
                            thenCalls.push(`Reflect.defineProperty(__proto__, Symbol.toStringTag, {value: String.fromCharCode(${windowTag.split("").map(c => c.charCodeAt())}) })`)
                        }
                        if (!config.keepWindowObjects) {
                            thenCalls.push(`Reflect.ownKeys(self).forEach(Reflect.deleteProperty.bind(Reflect, self))`);
                        }
                        const thenCall = thenCalls.length && String(`.then(wasm => [${thenCalls}])`) || String();
                        let wasmGenerator = ``;
                        if (config.generateWASMFromHEXString && !config.generateWASMFromNumberArray) {
                            wasmGenerator = `Uint8Array.from(/${wasmhex}/.toString().match(/[a-f0-9]{2}/g).map(h => parseInt(h, 16)))`;
                        }
                        else if (!config.generateWASMFromHEXString && config.generateWASMFromNumberArray) {
                            wasmGenerator = `Uint8Array.of(${wasmhex.toString().match(/[a-f0-9]{2}/g).map(h => parseInt(h, 16))})`;
                        }
                        const onload = [
                            `WebAssembly.instantiate(${wasmGenerator}, self)`.concat(thenCall)
                        ];
                        if (!config.keepFaviconRequest && config.faviconLinkHref) {
                            const faviconHTML = `<link rel=icon href=${config.faviconLinkHref}>`;
                            onload.push(`Reflect.set(document.head, String.fromCharCode(${'innerHTML'.split("").map(c => c.charCodeAt())}), String.fromCharCode(${faviconHTML.split("").map(c => c.charCodeAt())}))`)
                        }
                        filecontent = `<body onload="[${onload}]"></body>`;
                    }
                    const filename = wasmFile
                        .substring(0, wasmFile.lastIndexOf("."))
                        .concat(".")
                        .concat(extension);
                    fs.writeFileSync(filename, filecontent);
                    if (config.unlinkWat4FileIfCompilationSuccess) {
                        try { fs.unlinkSync(wasmFile); } catch (e) { }
                    }
                }
            } else {
                console.error(`💥 wat2wasm failed with exit code ${result.status}`);
                PROCESS.exit(result.status);
            }
        }
    } catch (err) {
        console.error(`\n💥 ERROR:`, err);
        PROCESS.exit(1);
    } finally {
        console.log("\x1b[0m")
    }
}


const processors = [
    W4W,
    TEXT,
    ASYNC,
    DATA,
    IMPORT,
    INCLUDE,
    NEW,
    REF_EXTERN,
    REF_FUNC,
    START,
    STRING,
    REPLACE_ALL,
];
processCLI(async wat4 => {
    let wat2 = wat4, f, i = -1, llen, m = -1, c = 0, ci = 0;
    while (f = processors[++i]) {
        wat4 = f(wat2, W4W).toString();
        const input = wat2;
        const output = wat4;
        const inLines = input.split("\n").map(l => l.trim()).filter(Boolean);
        const outLines = output.split("\n").map(l => l.trim()).filter(Boolean);
        let startCommon = 0;
        while (
            startCommon < inLines.length &&
            startCommon < outLines.length &&
            inLines[startCommon] === outLines[startCommon]
        ) { startCommon++; }
        let endCommon = 0;
        while (
            endCommon < inLines.length - startCommon &&
            endCommon < outLines.length - startCommon &&
            inLines[inLines.length - 1 - endCommon] === outLines[outLines.length - 1 - endCommon]
        ) { endCommon++; }
        const commonLines = startCommon + endCommon;
        const removedLines = inLines.length - commonLines;
        const addedLines = outLines.length - commonLines;
        const netChange = outLines.length - inLines.length;
        const stat = [
            `\x1b[32m+${addedLines}\x1b[0m`.padStart(15, " "),
            `\x1b[34m-${removedLines}\x1b[0m`.padStart(15, " "),
            `\x1b[${netChange && 36 || 33}m\u0394\x1b[0m`.padStart(12, " "),
            `\x1b[${netChange && 36 || 33}m${netChange}\x1b[0m`.padStart(12, " "),
            `  byte(\u03B4) :`,
            `\x1b[33m${wat2.length}\x1b[0m`.padStart(14, " "),
            `-->`,
            `\x1b[33m${wat4.length}\x1b[0m`,
        ];
        if (wat2 !== wat4) {
            c++;
            wat2 = wat4;
            console.log(`👀 ƒ(  ${f.name.padEnd(12, " ")} )`.padStart(12, " "), ...stat);
        }
        if (!processors[i + 1]) {
            if (c) { i = -1; c = 0; }
            else { console.log("☘️  untouched raw \x1b[32m-->\x1b[0m finalizing..") }
        }
    }
    wat2 = clean(wat2);
    wat2 = wat4beauty(wat2, "  ");
    return wat2;
});

